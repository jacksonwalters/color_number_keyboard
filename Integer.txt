If we are feeling fancy, we could promote the natural numbers to a category where each
object represents the concept of a number, and the symbolic string is viewed as a label or
representative of an isomorphism class of finite sets of a given size, the morphisms
in set simply being maps, i.e.

[3] = [{a,b,c}] = [{1,2,3}] = [{0,1,2}] = [{0,1,10}]

where in the last set the labels should be viewed as binary strings. The operation 'taking
brackets' can be interpreted as 'choose any distinguishable symbols you want'.

The morphisms in this category are injective, bijective, and surjective maps between
finite sets, the adjectives corresponding to the relative size of the
domain and codomain.

We have to be very careful with surjective maps - one can measure
the 'smoothness' of a surjective map by looking at how often each element in the
codomain gets hit, i.e. look at the size #f^{-1}(b) for a in the codomain. We want to take
maps which are 'smooth' in the sense that they distribute elements from the domain evenly
across the codomain.

Define the *index* of a surjective map as max(#f^(-1)(b) for b in codomain of f). Maps with
high index are very degenerate - they are piling a bunch of stuff from the domain onto a
single element in the codomain.

Suppose m|n. Then n/m is an integer. If f: [n] -> [m] is smooth iff index(f) = n/m.

For example, consider the morphisms [3]=[{a,b,c}] -> [3]=[{a,b,c}].
These are the maps

[{a,b,c} -> {a,b,c}] = [{x,y,z} -> {x,y,z}] = S_3, i.e.

the permutations of 3 elements, i.e. all maps of a 3 element set to a 3 element set. This
can be viewed as the permutation group S_3.

Hom([4],[3]) = [{a,b,c,X} -> {a,b,c}] = [S_3 x in_1,3]

where in_1,3: [1] -> [3] is the inclusion map taking one element (think X) to one of {a,b,c}.

Hom([4],[2]) = [{a,b,c,d} -> {a,b}] seems to have a little extra structure.
Hom([4],[2]) = S_2 x S_2, i.e. decide where the first two elements go, then the second two.
This can be formalized by noting that the product in set is disjoint union, so we have
something like [{a,b} \cup {a,b} -> {a,b}].

If we feel so inclined, we could introduce a notion of homotopy of maps between finite sets.
This should have the effect making all bijections equivalent to the identity. We want to
allow the 'arrows' telling which element goes to which to be reordered. For example,
let S_3 = [{a,b,c} -> {a,b,c}]. One of these maps is [a,b,c] -> [c,b,a]. If we allow
S_3 to act on the set of maps S_3 = [{a,b,c} -> {a,b,c}], we can use the transposition
(1 3) to swap the a -> c and c -> a.

In general, we can say two maps f,g: [n] -> [n] are homotopic if there exists \sigma \in
S_n such that \sigma f = g. Denote the homotopy class of f by [[f]].
Clearly all maps are equivalent, #[[f]] = 1 under this relation.

Let's extend to morphisms [n] -> [m] where n > m. Hom([n],[m]) = [S_n x in_(n-m),m]. We
can view a homotopy as 'cleaning up' the criss-crossed arrows. For example, take n=4, m=2.

Choose representative symbols and consider the maps {a,b,c,d} -> {1,2}.
Let f = (a -> 1, b -> 2, c -> 2, d -> 1). The first two arrows are already 'straight'.
The second two need to be flipped, so we act on them by \sigma to organize them resulting
in

\sigma f = (a -> 1, b -> 2, c -> 1, d -> 2). We are really just doing combinatorics.
Hom([4],[2]) = {
(a -> 1, b -> 1, c -> 2, d -> 2)	#[a,b] -> 1, [c,d] -> 2
(a -> 1, b -> 2, c -> 1, d -> 2)	#[a,c] -> 1, [c,d] -> 2
(a -> 1, b -> 2, c -> 2, d -> 1)  #[a,d] -> 1, [d,b] -> 2
(a -> 2, b -> 1, c -> 1, d -> 2)  #[b,c] -> 1, [c,a] -> 2
(a -> 2, b -> 1, c -> 2, d -> 1)  #[b,d] -> 1, [d,a] -> 2
(a -> 2, b -> 2, c -> 1, d -> 1)  #[c,d] -> 1, [d,b] -> 2
}

Removing dependencies on symbols, every map looks like two copies of [2] -> [1].

Take n=5, m=2. We should get floor(5/2)=2 copies of [2] -> [1], and one map
[1] -> [5]. This is looking like division with remainder, i.e. 5=2*2+1.

Once we have this category Number in hand, we can start to define functors
F: Number -> Number, or F: Number x Number -> Number i.e. unary operations
and binary operations. Operations like multiplication and addition should be
natural, i.e. they should at least be well defined in the sense that they do
not depend on the base we represent them in. These functors are typically
defined as grade school algorithms like add and carry in binary or base-10.
I propose calling naming Hom(\cup_k Number,Number) Calculator_r, and think
of them as r-ary operations on positive integers.

We can write down these algorithms, or implement them in hardware. Hardware
sheds light on the fact that these 'circuits' are rather complicated, and it
is far from obvious what the relationship between multiplication and addition
might be. However, we intuitively know that they play nicely together as
together they turn Number into a semiring.

With this perspective, we can talk about natural
transformations of functors, i.e. how operations on numbers are related to each
other.

- Jackson Walters
